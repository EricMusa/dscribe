Smooth Overlap of Atomic Positions
==================================

Smooth Overlap of Atomic Positions (SOAP) is a rotationally and permutationally invariant (atom-centered) local descriptor which uses gaussian-smoothing and spherical harmonics. It has been conceived in 2013:

"Comparing molecules and solids across structural and alchemical space - Sandip De, Albert P. Bartók, Gábor Cásnyi, and Michele Ceriotti, Phys. Rev. B 87, 184115, 2013"

The current implementation is based on 

"Machine learning hydrogen adsorption on nanoclusters through structural descriptors - Marc O. J. Jäger, Eiaki V. Morooka, Filippo Federici Canova, Lauri Himanen & Adam S. Foster, npj Computational Materials, 4, 37, 2018"

Instantiation
-------------

As every descriptor in DScribe SOAP needs to be setup as it requires a few parameters:

.. code-block:: python

    import ase
    from dscribe.descriptors import SOAP
    atomic_numbers = [1,8]
    rcut = 6.0
    nmax = 8
    lmax = 6
    soap = SOAP(atomic_numbers, rcut, nmax, lmax)

The argument *atomic_numbers* lists the elements in the system(s) to be described. 
The 3 SOAP-specific positional arguments are *rcut*, *nmax* and *lmax*. The cutoff radius rcut defines how large the environment is. Atoms within this range are considered neighbours and influence the descriptor. Since a smooth cutoff-function is used, sudden changes of configurations at the cutoff distance are mitigated.
Increasing the arguments *nmax* and *lmax* makes SOAP more accurate but also increases the number of features.

Creation
--------

Let's first create an ase object of the water molecule. 

.. code-block:: python

    from ase.structure import molecule
    water = molecule("H2O")

Adding SOAP to the water is as easy as: 

.. code-block:: python

    soap_water = soap.create(water)

    print(soap_water)
    print(soap_water.shape)

We are expecting a matrix where each row represents the local environment of one atom of the molecule. The nth feature vector corresponds to the local SOAP around the nth atom of the ase object. The length of the feature vector depends on the number of species defined in *atomic_numbers* as well as *nmax* and *lmax*. You can try by changing *nmax* and *lmax*.

.. code-block:: python

    minimal_soap = SOAP(atomic_numbers, rcut, 2, 0)
    n_features =  minimal_soap.get_number_of_features())

    print("minimal number of features", n_features)



Let's SOAP another molecule. In order to compare water with methanol, one needs to adapt the species in atomic_numbers first defined when initializing SOAP. Adding carbon (atomic number = 6) will not affect the previous features of water, it will merely add zero-padded regions to the feature vector.

.. code-block:: python

    print("previous sum", soap_water.sum(axis = 1))

    atomic_numbers = [1, 6, 8]
    soap = SOAP(atomic_numbers, rcut, nmax, lmax)

    soap_water = soap.create(water)

    print(soap_water.shape)
    print("unchanged sum", soap_water.sum(axis = 1))

    methanol = molecule("CH3OH")
    soap_methanol = soap.create(methanol)

    print(soap_methanol.shape)


Optional Parameters
-------------------

sparse
------

If the descriptor size is large (this can be the case for instance with a myriad of different element types as well as high *nmax* and *lmax*) more often than not considerable parts of the features will be zero. Saving the result in sparse matrix format saves memory. DScribe does so by default using the scipy module. Be aware between the different types:  

.. code-block:: python

    soap = SOAP(atomic_numbers, rcut, nmax, lmax, sparse = True)
    soap_water = soap.create(water)
    print(type(soap_water))

    soap = SOAP(atomic_numbers, rcut, nmax, lmax, sparse = False)
    soap_water = soap.create(water)
    print(type(soap_water))

Most operations work on sparse matrices as they would on numpy matrices. Otherwise, a sparse matrix can simply be converted calling the *.toarray()* method. For further information check the `scipy documentation <https://docs.scipy.org>`_ on sparse matrices.


average
-------

One way of turning a local descriptor into a global descriptor is by taking the average over all atoms. Since SOAP separates features by atom types, this essentially means averaging over atoms of the same type. 

.. code-block:: python

    average_soap = SOAP(atomic_numbers, rcut, nmax, lmax, average = True, sparse = False)

    soap_water = average_soap.create(water)
    print("average soap water", soap_water.shape)

    soap_methanol = average_soap.create(methanol)
    print("average soap methanol", soap_methanol.shape)

    h2o2 = molecule('H2O2')
    soap_peroxide = average_soap.create(h2o2)


The result will be a feature vector and not a matrix, so it no longer depends on the system size. This is necessary to compare two or more structures with different number of elements. We can do so by applying the distance metric of our choice. 

.. code-block:: python

    from scipy.spatial.distance import pdist, squareform
    import numpy as np
    molecules = np.vstack([soap_water, soap_methanol, soap_peroxide])
    distance = squareform(pdist(molecules))
    print("distance matrix: water - methanol - H2O2")
    print(distance)


It seams that the local environments of water and hydrogen peroxide are more similar to each other. There are other ways to compare structures of different sizes with each other. In dscribe.utils the average and rematch kernel are provided (see below). 


periodic
--------

Crystals can also be SOAPed by simply setting the *periodic* keyword to True. A cell needs to be defined within the ase object.

.. code-block:: python

    from ase.build import bulk
    copper = bulk('Cu', 'fcc', a=3.6, cubic = True)
    print(copper.get_pbc())
    atomic_numbers = [29]
    periodic_soap = SOAP(atomic_numbers, rcut, nmax, lmax, periodic = True, sparse = False)
    soap_copper = periodic_soap.create(copper)

    print(soap_copper)
    print(soap_copper.sum(axis = 1))

Since the SOAP feature vectors of each of the four copper atoms in the cubic unit cell match, they turn out to be equivalent.


Utilities
---------

batch_create
------------

In machine learning we usually want to compare many structures with each other. With the above functions, it is possible to iterate over a list of ase ojects. The utility function *batch_create* handles this automatically for you. 

.. code-block:: python

    from dscribe.utils import batch_create

    molecule_lst = [water, methanol]
    batch = batch_create(average_soap, molecule_lst, n_proc = 1)
    print(batch.shape)

Implementation note: If you specify *average = False*, you can only run one local environment per molecule. That means you would need to specify one location using the optional parameter positions. We are going to alleviate this constraint soon. Try if it works now, the tutorial might not catch up with the development!


AverageKernel and RematchKernel
-------------------------------

SOAP is a local descriptor. However, it can be made global for instance by averageing over the local environments of the whole molecule. Condensing the local feature matrix into a global feature vector makes it possible to compare structures of different sizes (and compositions).

.. code-block:: python

    from dscribe.utils import AverageKernel
    ave = AverageKernel()
    avemat = ave.get_global_distance_matrix([soap_water, soap_methanol])

    print(avemat)


An alternative is the ReMatch kernel, which lets you choose between the best match of local environments and the above averaging strategy. The parameter *gamma* determines the contribution of the two whereas *gamma = 0* means only the similarity of the best matching local environments is taken into account and *gamma* going towards infinite channels in the average solution. 


.. code-block:: python

    from dscribe.utils import RematchKernel

    rematch = RematchKernel()
    envkernels = rematch.get_all_envkernels([soap_water, soap_methanol])
    remat = rematch.get_global_kernel(envkernels, gamma = 0.1, threshold = 1e-6)

    print(remat)


For further reading, consider the original article:

"Comparing molecules and solids across structural and alchemical space - Sandip De, Albert P. Bartók, Gábor Cásnyi, and Michele Ceriotti, Phys. Chem. Chem. Phys., 18, 13754-13769, 2016"


The collections of python-lines is also available in dscribe/examples.